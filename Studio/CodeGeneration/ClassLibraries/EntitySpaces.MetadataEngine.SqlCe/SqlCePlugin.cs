/* 
-------------------------------------------------------------------------------
                           EntitySpaces, LLC
                       SOFTWARE LICENSE AGREEMENT
			
This License Agreement is between you (?Customer?) and EntitySpaces, LLC, the
author of the EntitySpaces? software and governs your use of the of the 
EntitySpaces class libraries, dynamic link libraries, source code, related 
EntitySpaces templates for MyGeneration Software, and documentation (all
of which are referred to herein as the "Software").

PLEASE READ THIS SOFTWARE LICENSE AGREEMENT CAREFULLY BEFORE PURCHASING, 
DOWNLOADING OR USING THE SOFTWARE. NO REFUNDS ARE POSSIBLE. BY PURCHASING, 
INSTALLING, OR DOWNLOADING THE SOFTWARE, YOU ARE CONSENTING TO BE BOUND BY 
THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF THIS AGREEMENT, 
DO NOT DOWNLOAD OR PURCHASE THE SOFTWARE.

Our developer licenses are licensed per developer seat. A developer seat is
required for each developer that uses the EntitySpaces API which includes the
generated classes in their programming tasks. 

EntitySpaces, LLC grants Customer a non-exclusive right to install and use one
copy of Software for each License purchased. 

Customer may make one (1) archival copy of the Software provided Customer 
affixes to such copy all copyright, confidentiality, and proprietary notices
that appear on the original. 

The binary redistributables listed below are royalty free to the original 
Licensee and can be distributed with applications. Binary redistributables 
include:

Binary Redistributables for EntitySpaces 2008
=============================================
EntitySpaces.Core.dll
EntitySpaces.Interfaces.dll

EntitySpaces.SqlClientProvider.dll
EntitySpaces.SqlCeClientProvider.dll
EntitySpaces.MSAccessProvider.dll
EntitySpaces.OracleClientProvider.dll
EntitySpaces.MySqlClientProvider.dll
EntitySpaces.VistaDBProvider.dll
EntitySpaces.NpgsqlProvider.dll

EntitySpaces.Web.dll
EntitySpaces.Web.Design.dll
EntitySpaces.Loader.dll
EntitySpaces.LoaderMT.dll

EntitySpaces.Core.CF.dll
EntitySpaces.Interfaces.CF.dll
EntitySpaces.SqlCeClientProvider.CF.dll
EntitySpaces.VistaDBProvider.CF.dll
EntitySpaces.Loader.CF.dll
EntitySpaces.LoaderMT.CF.dll

Binary Redistributables for EntitySpaces 2007
=============================================
EntitySpace.Core.dll
EntitySpaces.Interfaces.dll

EntitySpaces.SqlClientProvider.dll
EntitySpaces.MSAccessProvider.dll
EntitySpaces.OracleClientProvider.dll
EntitySpaces.MySqlClientProvider.dll
EntitySpaces.VistaDBProvider.dll
EntitySpaces.NpgsqlProvider.dll

EntitySpaces.Web.dll
EntitySpaces.Web.Design.dll
EntitySpaces.Loader.dll
EntitySpaces.LoaderMT.dll

EntitySpaces.Core.Ce.dll
EntitySpaces.Interfaces.Ce.dll
EntitySpaces.SqlClientProvider.Ce.dll
EntitySpaces.VistaDBProvider.Ce.dll
EntitySpaces.Loader.Ce.dll
EntitySpaces.LoaderMT.Ce.dll

EntitySpaces binary redistributables cannot be used by third parties to build
applications or components.

** NOTE: **
==================================
The EntitySpaces.MetadataEngine.dll is a NON-redistributables binary assembly. This 
assembly CANNOT be distributed for any reason or used to build any third party
applications.

Source code generated by the EntitySpaces templates for MyGeneration is a 
derivative work. When used under a valid License, EntitySpaces, LLC grants 
Customer the right to use, modify, and redistribute any source code generated
by the EntitySpaces templates for MyGeneration or CodeSmith.

Customer that has purchased Source Code License may alter the EntitySpaces Core,
Interfaces, or Provider(s) source code and distribute the modified binary 
redistributables with applications. Customer created binary redistributables 
from the EntitySpaces source code cannot be used by anyone, including the 
original license holder, to create a product that competes with the EntitySpaces 
.NET Architecture. Customer created binary redistributables from the 
EntitySpaces source code cannot be used by third parties to build applications 
or components. Neither the original nor altered source code may be distributed.

EXCEPT AS EXPRESSLY AUTHORIZED ABOVE, CUSTOMER SHALL NOT: COPY, IN WHOLE OR IN 
PART, SOFTWARE OR DOCUMENTATION; MODIFY THE SOFTWARE; REVERSE COMPILE OR REVERSE 
ASSEMBLE ALL OR ANY PORTION OF THE SOFTWARE; OR RENT, LEASE, DISTRIBUTE, SELL, 
MAKE AVAILABLE FOR DOWNLOAD, OR CREATE DERIVATIVE WORKS OF THE SOFTWARE OR 
SOURCE CODE. 

Customer agrees that aspects of the licensed materials, including the specific
design and structure of individual programs, constitute trade secrets and/or 
copyrighted material of EntitySpaces, LLC. Customer agrees not to disclose, 
provide, or otherwise make available such trade secrets or copyrighted material 
in any form to any third party without the prior written consent of EntitySpaces, 
LLC. Customer agrees to implement reasonable security measures to protect such 
trade secrets and copyrighted material. Title to Software and documentation 
shall remain solely with EntitySpaces, LLC.

Not for Resale Software
=======================
Software identified as "Not for Resale" or "NFR," may not be sold or otherwise 
transferred for value or given away, or used for any purpose other than 
demonstration, test or evaluation.

No Warranty
=======================
THE SOFTWARE IS BEING DELIVERED TO YOU "AS IS" AND EntitySpaces, LLC MAKES NO
WARRANTY AS TO ITS USE, RELIABILITY OR PERFORMANCE. EntitySpaces, LLC DOES NOT
AND CANNOT WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY USING THE 
SOFTWARE. EntitySpaces, LLC MAKES NO WARRANTIES, EXPRESS OR IMPLIED, AS TO 
NONINFRINGEMENT OF THIRD PARTY RIGHTS, TITLE, MERCHANTABILITY, OR FITNESS FOR
ANY PARTICULAR PURPOSE. YOU ASSUME ALL RISK ASSOCIATED WITH THE QUALITY, 
PERFORMANCE, INSTALLATION AND USE OF THE SOFTWARE INCLUDING, BUT NOT LIMITED TO, 
THE RISKS OF PROGRAM ERRORS, DAMAGE TO EQUIPMENT, LOSS OF DATA OR SOFTWARE 
PROGRAMS, OR UNAVAILABILITY OR INTERRUPTION OF OPERATIONS. YOU ARE SOLELY 
RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USE OF THE SOFTWARE AND 
ASSUME ALL RISKS ASSOCIATED WITH ITS USE.

Indemnification
=======================
You agree to indemnify and hold EntitySpaces, LLC, parents, subsidiaries, 
affiliates, officers and employees, harmless from any claim or demand, 
including reasonable attorneys' fees, made by any third party due to or arising 
out of your use of the Software, or the infringement by you, of any intellectual 
property or other right of any person or entity.

Limitation of Liability
=======================
IN NO EVENT WILL EntitySpaces, LLC BE LIABLE TO YOU FOR ANY INDIRECT, INCIDENTAL, 
SPECIAL, PUNITIVE, CONSEQUENTIAL, OR OTHER DAMAGES WHATSOEVER, OR ANY LOSS OF 
REVENUE, DATA, USE, OR PROFITS, EVEN IF EntitySpaces, LLC HAS BEEN ADVISED OF 
THE POSSIBILITY OF SUCH DAMAGES, AND REGARDLESS OF WHETHER THE CLAIM IS BASED 
UPON ANY CONTRACT, TORT OR OTHER LEGAL OR EQUITABLE THEORY.

This License is effective until terminated. Customer may terminate this License 
at any time by destroying all copies of Software including any documentation. 
This License will terminate immediately without notice from EntitySpaces, LLC 
if Customer fails to comply with any provision of this License. Upon termination, 
Customer must destroy all copies of Software.

Software, including technical data, is subject to U.S. export control laws, 
including the U.S. Export Administration Act and its associated regulations, 
and may be subject to export or import regulations in other countries. Customer 
agrees to comply strictly with all such regulations and acknowledges that it 
has the responsibility to obtain licenses to export, re-export, or import 
Software.

This License shall be governed by and construed in accordance with the laws of 
the State of Indiana, United States of America, as if performed wholly within 
the state and without giving effect to the principles of conflict of law. If 
any portion hereof is found to be void or unenforceable, the remaining 
provisions of this License shall remain in full force and effect. This License 
constitutes the entire License between the parties with respect to the use of 
the Software.
------------------------------------------------------------------------------- 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Data;
using System.Data.Common;
using System.Reflection;

using EntitySpaces.MetadataEngine;

//using System.Data.SqlServerCe;

namespace MyMeta.Plugins
{
    public class SqlCePlugin : IPlugin
	{
        static private AppDomain _appDomain;

		#region IPlugin Interface

		private IContext context;

        bool IPlugin.OnLoad()
        {
            _appDomain = AppDomain.CreateDomain("EntitySpaces.MetadataEngine.SqlCe");
            return _appDomain != null;
        }

        void IPlugin.OnUnload()
        {
            if (_appDomain != null)
            {
                AppDomain.Unload(_appDomain);
                _appDomain = null;
            }
        }

        void IPlugin.Initialize(IContext context)
        {
            this.context = context;
        }

        string IPlugin.ProviderName
        {
            get { return @"Microsoft SQL CE"; }
        }

        string IPlugin.ProviderUniqueKey
        {
            get { return @"SQLCE"; }
        }

        string IPlugin.ProviderAuthorInfo
        {
            get { return @"Microsoft SQL CE Plugin"; }
        }

        Uri IPlugin.ProviderAuthorUri
        {
            get { return new Uri(@"http://www.entityspaces.net/"); }
        }

        bool IPlugin.StripTrailingNulls
        {
            get { return false; }
        }

        bool IPlugin.RequiredDatabaseName
        {
            get { return false; }
        }

        string IPlugin.SampleConnectionString
        {
            get { return @"Data Source=C:\Program Files\Microsoft SQL Server Compact Edition\v3.1\SDK\Samples\Northwind.sdf"; }
        }

        IDbConnection IPlugin.NewConnection
        {
            get
            {
                if (IsIntialized)
				{
                    IDbConnection cn =  SqlCePlugin.CreateConnection(this.context.ConnectionString);
                    cn.Open();
                    return cn;
				}
                else
                    return null;
            }
        }

        string IPlugin.DefaultDatabase
        {
            get
            {
				return this.GetDatabaseName();
            }
        }

        DataTable IPlugin.Databases
        {
            get
            {
				DataTable metaData = new DataTable();

				try
				{
					metaData = context.CreateDatabasesDataTable();

					DataRow row = metaData.NewRow();
					metaData.Rows.Add(row);

					row["CATALOG_NAME"] = GetDatabaseName();
                    //row["DESCRIPTION"]  = db.Description;
				}
				finally
				{

				}

				return metaData;
            }
        }

        DataTable IPlugin.GetTables(string database)
        {
            IDataReader reader = null;
            DataTable metaData = new DataTable();

            try
            {
                metaData = context.CreateTablesDataTable();

                string query = "SELECT TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE='TABLE'";
                IDbCommand cmd = SqlCePlugin.CreateCommand(query, this.context.ConnectionString);

                reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);

                while (reader.Read())
                {
                    DataRow row = metaData.NewRow();
                    metaData.Rows.Add(row);

                    row["TABLE_CATALOG"] = reader.GetValue(0);
                    row["TABLE_SCHEMA"] = reader.GetValue(1);
                    row["TABLE_NAME"] = reader.GetValue(2);
                }
            }
            catch (Exception ex)
            {
                string s = ex.Message;
            }
			finally
			{
                if (reader != null)
                {
                    reader.Close();
                }
			}

			return metaData;
        }

		DataTable IPlugin.GetViews(string database)
		{
			DataTable metaData = new DataTable();
            return metaData;
		}

        DataTable IPlugin.GetProcedures(string database)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetDomains(string database)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetProcedureParameters(string database, string procedure)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetProcedureResultColumns(string database, string procedure)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetViewColumns(string database, string view)
        {
            DataTable metaData = new DataTable();
            return metaData;
        }

        DataTable IPlugin.GetTableColumns(string database, string table)
        {
            IDataReader reader = null;
            DataTable metaData = new DataTable();

            try
            {
                metaData = context.CreateColumnsDataTable();

                string query = "SELECT * FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='" + table + "'";
                IDbCommand cmd = SqlCePlugin.CreateCommand(query, this.context.ConnectionString);

                reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);

                while (reader.Read())
                {
                    DataRow row = metaData.NewRow();
                    metaData.Rows.Add(row);

                    row["TABLE_CATALOG"] = reader["TABLE_CATALOG"];
                    row["TABLE_SCHEMA"] = reader["TABLE_SCHEMA"];
                    row["TABLE_NAME"] = reader["TABLE_NAME"];
                    row["COLUMN_NAME"] = reader["COLUMN_NAME"];
                    row["ORDINAL_POSITION"] = reader["ORDINAL_POSITION"];
                    row["DESCRIPTION"] = reader["DESCRIPTION"];

                    if (reader["IS_NULLABLE"] != DBNull.Value)
                    {
                        string isNullable = reader.GetString(reader.GetOrdinal("IS_NULLABLE"));
                        isNullable = isNullable.ToUpper();
                        row["IS_NULLABLE"] = (isNullable == "NO") ? false : true;
                    }

                    if (reader.GetBoolean(reader.GetOrdinal("COLUMN_HASDEFAULT")))
                    {
                        row["COLUMN_HASDEFAULT"] = true;
                        row["COLUMN_DEFAULT"] = reader["COLUMN_DEFAULT"];
                    }

                    if (reader["AUTOINC_INCREMENT"] != DBNull.Value)
                    {
                        row["IS_AUTO_KEY"] = true;
                        row["AUTO_KEY_SEED"] = Convert.ToInt32(reader["AUTOINC_SEED"]);
                        row["AUTO_KEY_INCREMENT"] = Convert.ToInt32(reader["AUTOINC_INCREMENT"]);
                    }

                    string type = (string)reader["DATA_TYPE"];
                    int charMax = 0;
                    short precision = 0;
                    short scale = 0;

                    if (reader["CHARACTER_MAXIMUM_LENGTH"] != DBNull.Value)
                    {
                        charMax = (int)reader["CHARACTER_MAXIMUM_LENGTH"];
                    }

                    if (reader["NUMERIC_PRECISION"] != DBNull.Value)
                    {
                        precision = (short)reader["NUMERIC_PRECISION"];
                    }

                    if (reader["NUMERIC_SCALE"] != DBNull.Value)
                    {
                        scale = (short)reader["NUMERIC_SCALE"];
                    }

                    row["TYPE_NAME"] = type;
                    row["TYPE_NAME_COMPLETE"] = this.GetDataTypeNameComplete(type, charMax, precision, scale);

                    row["NUMERIC_PRECISION"] = precision;
                    row["NUMERIC_SCALE"] = scale;

                    row["CHARACTER_MAXIMUM_LENGTH"] = charMax;

                    row["IS_COMPUTED"] = (type == "timestamp") ? true : false;

                    row["IS_CONCURRENCY"] = (type == "rowversion" || type == "timestamp") ? true : false;
                }
            }
            catch (Exception ex)
            {
                string s = ex.Message;
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

            return metaData;
        }

        List<string> IPlugin.GetPrimaryKeyColumns(string database, string table)
        {
            IDataReader reader = null;
			List<string> primaryKeys = new List<string>();

            try
            {
                string query = "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.INDEXES where Table_Name='" + table + "' AND PRIMARY_KEY=1";
                IDbCommand cmd = SqlCePlugin.CreateCommand(query, this.context.ConnectionString);

                reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);

                while (reader.Read())
                {
                    primaryKeys.Add(reader.GetString(0));
                }
            }
            catch(Exception ex)
            {
                string s = ex.Message;
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

			return primaryKeys;
        }

        List<string> IPlugin.GetViewSubViews(string database, string view)
        {
            return new List<string>();
        }

        List<string> IPlugin.GetViewSubTables(string database, string view)
        {
            return new List<string>();
        }

        DataTable IPlugin.GetTableIndexes(string database, string table)
        {
            IDataReader reader = null;
			DataTable metaData = new DataTable();

            try
            {
                metaData = context.CreateIndexesDataTable();

                string query = "SELECT * FROM INFORMATION_SCHEMA.INDEXES WHERE TABLE_NAME='" + table + "'";
                IDbCommand cmd = SqlCePlugin.CreateCommand(query, this.context.ConnectionString);

                reader = cmd.ExecuteReader(CommandBehavior.CloseConnection);

                while (reader.Read())
                {
                    DataRow row = metaData.NewRow();
                    metaData.Rows.Add(row);

                    row["TABLE_NAME"] = reader["TABLE_NAME"];
                    row["INDEX_NAME"] = reader["INDEX_NAME"];
                    row["UNIQUE"] = reader["UNIQUE"];
                    row["CLUSTERED"] = reader["CLUSTERED"];
                    row["AUTO_UPDATE"] = reader["AUTO_UPDATE"];
                    row["SORT_BOOKMARKS"] = reader["SORT_BOOKMARKS"];
                    row["FILTER_CONDITION"] = reader["FILTER_CONDITION"];
                    row["NULL_COLLATION"] = reader["NULL_COLLATION"];
                    row["INITIAL_SIZE"] = reader["INITIAL_SIZE"];
                    row["CARDINALITY"] = Convert.ToDecimal(reader["CARDINALITY"]);
                    row["COLLATION"] = reader["COLLATION"];
                    row["COLUMN_NAME"] = reader["COLUMN_NAME"];
                    row["FILL_FACTOR"] = reader["FILL_FACTOR"];
                    row["AUTO_UPDATE"] = reader["AUTO_UPDATE"];
                    row["PRIMARY_KEY"] = reader["PRIMARY_KEY"];
                    row["NULLS"] = reader["NULLS"];
                    row["ORDINAL_POSITION"] = reader["ORDINAL_POSITION"];
                }
            }
            catch (Exception ex)
            {
                string s = ex.Message;
            }
            finally
            {
                if (reader != null)
                {
                    reader.Close();
                }
            }

			return metaData;
        }

        DataTable IPlugin.GetForeignKeys(string database, string table)
        {
			DataTable metaData = new DataTable();

            try
            {
                metaData = context.CreateForeignKeysDataTable();

                LoadForeignKeysPartOne(metaData, table);
                LoadForeignKeysPartTwo(metaData, table);
            }
            catch { }

			return metaData;
        }

        private void LoadForeignKeysPartOne(DataTable metaData, string table)
        {
            IDataReader fk = null;
            IDataReader pCols = null;
            IDataReader fCols = null;

            try
            {
                string query =
    "SELECT tc.*, rc.UPDATE_RULE, rc.DELETE_RULE, rc.UNIQUE_CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc " +
    "JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc ON tc.CONSTRAINT_NAME = rc.CONSTRAINT_NAME " +
    "WHERE tc.CONSTRAINT_TYPE='FOREIGN KEY' AND tc.TABLE_NAME = '" + table + "'";

                fk = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                while (fk.Read())
                {
                    //---------------------------------------
                    // Get the Primary Key and Columns
                    //---------------------------------------
                    query = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE CONSTRAINT_NAME='" + fk["UNIQUE_CONSTRAINT_NAME"] + "'";
                    pCols = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                    //---------------------------------------
                    // Get the Foreign Key Columns
                    //---------------------------------------
                    query = "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE CONSTRAINT_NAME = '" + fk["CONSTRAINT_NAME"] + "'";
                    fCols = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                    while (pCols.Read() && fCols.Read())
                    {
                        DataRow row = metaData.NewRow();
                        metaData.Rows.Add(row);

                        // The main Information ...
                        row["PK_TABLE_CATALOG"] = DBNull.Value;
                        row["PK_TABLE_SCHEMA"] = DBNull.Value;
                        row["FK_TABLE_CATALOG"] = DBNull.Value;
                        row["FK_TABLE_SCHEMA"] = DBNull.Value;
                        row["FK_TABLE_NAME"] = fk["TABLE_NAME"];
                        row["PK_TABLE_NAME"] = pCols["TABLE_NAME"];
                        row["ORDINAL"] = 0;
                        row["FK_NAME"] = fk["CONSTRAINT_NAME"];
                        row["UPDATE_RULE"] = fk["UPDATE_RULE"];
                        row["DELETE_RULE"] = fk["DELETE_RULE"];

                        bool isDeferrable = (bool)fk["IS_DEFERRABLE"];
                        bool initiallyDeferred = (bool)fk["INITIALLY_DEFERRED"];

                        if (isDeferrable)
                        {
                            row["DEFERRABILITY"] = initiallyDeferred ? 1 : 2;
                        }
                        else
                        {
                            row["DEFERRABILITY"] = 3;
                        }

                        row["PK_NAME"] = pCols["CONSTRAINT_NAME"];
                        row["PK_COLUMN_NAME"] = pCols["COLUMN_NAME"];
                        row["FK_COLUMN_NAME"] = fCols["COLUMN_NAME"];
                    }
                }
            }
            catch (Exception ex)
            {
                string s = ex.Message;
            }
            finally
            {
                if (fk != null)    fk.Close();
                if (pCols != null) pCols.Close();
                if (fCols != null) fCols.Close();
            }
        }

        private void LoadForeignKeysPartTwo(DataTable metaData, string table)
        {
            IDataReader fk = null;
            IDataReader pCols = null;
            IDataReader fCols = null;

            try
            {
                string query = "SELECT INDEX_NAME FROM INFORMATION_SCHEMA.INDEXES WHERE TABLE_NAME='" + table + "' AND PRIMARY_KEY=1";
                fk = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                string pkName = "";

                // Get primary key name
                if (fk.Read())
                {
                    pkName = (string)fk.GetValue(0);
                    fk.Close();
                }
                else return;

                // Got it
                query =
    "SELECT tc.*, rc.UPDATE_RULE, rc.DELETE_RULE, rc.UNIQUE_CONSTRAINT_NAME FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc " +
    "JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc ON tc.CONSTRAINT_NAME = rc.CONSTRAINT_NAME " +
    "WHERE tc.CONSTRAINT_TYPE='FOREIGN KEY' AND rc.UNIQUE_CONSTRAINT_NAME = '" + pkName + "'";

                fk = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                while (fk.Read())
                {
                    //---------------------------------------
                    // Get the Primary Key and Columns
                    //---------------------------------------
                    query = "SELECT * FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE CONSTRAINT_NAME='" + fk["UNIQUE_CONSTRAINT_NAME"] + "'";
                    pCols = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                    //---------------------------------------
                    // Get the Foreign Key Columns
                    //---------------------------------------
                    query = "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE WHERE CONSTRAINT_NAME = '" + fk["CONSTRAINT_NAME"] + "'";
                    fCols = SqlCePlugin.CreateCommand(query, this.context.ConnectionString).ExecuteReader(CommandBehavior.CloseConnection);

                    while (pCols.Read() && fCols.Read())
                    {
                        DataRow row = metaData.NewRow();
                        metaData.Rows.Add(row);

                        // The main Information ...
                        row["PK_TABLE_CATALOG"] = DBNull.Value;
                        row["PK_TABLE_SCHEMA"] = DBNull.Value;
                        row["FK_TABLE_CATALOG"] = DBNull.Value;
                        row["FK_TABLE_SCHEMA"] = DBNull.Value;
                        row["FK_TABLE_NAME"] = fk["TABLE_NAME"];
                        row["PK_TABLE_NAME"] = pCols["TABLE_NAME"];
                        row["ORDINAL"] = 0;
                        row["FK_NAME"] = fk["CONSTRAINT_NAME"];
                        row["UPDATE_RULE"] = fk["UPDATE_RULE"];
                        row["DELETE_RULE"] = fk["DELETE_RULE"];

                        bool isDeferrable = (bool)fk["IS_DEFERRABLE"];
                        bool initiallyDeferred = (bool)fk["INITIALLY_DEFERRED"];

                        if (isDeferrable)
                        {
                            row["DEFERRABILITY"] = initiallyDeferred ? 1 : 2;
                        }
                        else
                        {
                            row["DEFERRABILITY"] = 3;
                        }

                        row["PK_NAME"] = pCols["CONSTRAINT_NAME"];
                        row["PK_COLUMN_NAME"] = pCols["COLUMN_NAME"];
                        row["FK_COLUMN_NAME"] = fCols["COLUMN_NAME"];
                    }
                }
            }
            catch (Exception ex)
            {
                string s = ex.Message;
            }
            finally
            {
                if (fk != null) fk.Close();
                if (pCols != null) pCols.Close();
                if (fCols != null) fCols.Close();
            }
        }

        public object GetDatabaseSpecificMetaData(object myMetaObject, string key)
        {
            return null;
        }

		#endregion

		#region Internal Methods

        private bool IsIntialized 
		{ 
			get 
			{ 
				return (context != null); 
			} 
		}

		public string GetDatabaseName()
		{
            IDbConnection cn = SqlCePlugin.CreateConnection(context.ConnectionString);
            string dbName = cn.Database;

            int index = dbName.LastIndexOfAny(new char[] { '\\' });
            if (index >= 0)
            {
                dbName = dbName.Substring(index + 1);
            }

			return dbName;
		}

		public string GetFullDatabaseName()
		{
            IDbConnection cn = SqlCePlugin.CreateConnection(context.ConnectionString);
            return cn.Database;
		}

		#endregion

        #region Other Methods

        private string GetDataTypeNameComplete(string dataType, int charMax, short precision, short scale)
        {
            switch (dataType)
            {
                case "binary":
                case "char":
                case "nchar":
                case "nvarchar":
                case "varchar":
                case "varbinary":
                    return dataType + "(" + charMax + ")";

                case "decimal":
                case "numeric":
                    return dataType + "(" + precision + "," + scale + ")";

                default:
                    return dataType;
            }
        }

        #endregion

        static internal string nameSpace = "System.Data.SqlServerCe.";

        #region Domain/Reflection

        static internal IDbConnection CreateConnection(string connStr)
        {
            IDbConnection cn = _appDomain.CreateInstanceAndUnwrap
            (
                "System.Data.SqlServerCe," + GetAssemblyVersion(connStr),
                "System.Data.SqlServerCe.SqlCeConnection",
                false,
                BindingFlags.Default,
                null,
                new object[] { GetConnectionString(connStr) }, 
                null, 
                null, 
                null
            ) as IDbConnection;

            return cn;
        }

        static internal DbDataAdapter CreateAdapter(string query, string connStr)
        {
            DbDataAdapter adapter = _appDomain.CreateInstanceAndUnwrap
            (
                "System.Data.SqlServerCe," + GetAssemblyVersion(connStr),
                "System.Data.SqlServerCe.SqlCeDataAdapter",
                false,
                BindingFlags.OptionalParamBinding,
                null,
                new object[] { query, GetConnectionString(connStr) },
                null,
                null,
                null
            ) as DbDataAdapter;

            return adapter;
        }

        static internal IDbCommand CreateCommand(string commandText, string connStr)
        {
            IDbCommand cmd = _appDomain.CreateInstanceAndUnwrap
            (
                "System.Data.SqlServerCe," + GetAssemblyVersion(connStr),
                "System.Data.SqlServerCe.SqlCeCommand",
                false,
                BindingFlags.OptionalParamBinding,
                null,
                new object[] { commandText },
                null,
                null,
                null
            ) as IDbCommand;

            IDbConnection cn = SqlCePlugin.CreateConnection(connStr);

            cmd.Connection = cn;
            cn.Open();

            return cmd;
        }

        // "System.Data.SqlServerCe, Version=3.5.1.0, Culture=neutral, PublicKeyToken=89845dcd8080cc91",
        static public string GetAssemblyVersion(string connection)
        {
            try
            {
                string[] connInfo = connection.Split(';');

                foreach (string entry in connInfo)
                {
                    string[] parts = entry.Split('=');

                    if (parts[0].ToLower() == "version")
                    {
                        return entry;
                    }
                }
            }
            catch { }

            return "";
        }

        static internal string GetConnectionString(string connectionString)
        {
            string[] connInfo = connectionString.Split(';');

            string trueConnectionString = String.Empty;

            foreach (string entry in connInfo)
            {
                if (entry == String.Empty) break;

                string[] parts = entry.Split('=');

                if (parts[0].ToLower() != "version")
                {
                    trueConnectionString += entry + ";";
                }
            }

            return trueConnectionString;
        }

        #endregion
    }
}