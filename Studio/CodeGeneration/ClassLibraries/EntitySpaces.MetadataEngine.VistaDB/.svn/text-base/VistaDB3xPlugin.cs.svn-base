/* 
-------------------------------------------------------------------------------
                           EntitySpaces, LLC
                       SOFTWARE LICENSE AGREEMENT
			
This License Agreement is between you (?Customer?) and EntitySpaces, LLC, the
author of the EntitySpaces? software and governs your use of the of the 
EntitySpaces class libraries, dynamic link libraries, source code, related 
EntitySpaces templates for MyGeneration Software, and documentation (all
of which are referred to herein as the "Software").

PLEASE READ THIS SOFTWARE LICENSE AGREEMENT CAREFULLY BEFORE PURCHASING, 
DOWNLOADING OR USING THE SOFTWARE. NO REFUNDS ARE POSSIBLE. BY PURCHASING, 
INSTALLING, OR DOWNLOADING THE SOFTWARE, YOU ARE CONSENTING TO BE BOUND BY 
THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF THIS AGREEMENT, 
DO NOT DOWNLOAD OR PURCHASE THE SOFTWARE.

Our developer licenses are licensed per developer seat. A developer seat is
required for each developer that uses the EntitySpaces API which includes the
generated classes in their programming tasks. 

EntitySpaces, LLC grants Customer a non-exclusive right to install and use one
copy of Software for each License purchased. 

Customer may make one (1) archival copy of the Software provided Customer 
affixes to such copy all copyright, confidentiality, and proprietary notices
that appear on the original. 

The binary redistributables listed below are royalty free to the original 
Licensee and can be distributed with applications. Binary redistributables 
include:

Binary Redistributables for EntitySpaces 2008
=============================================
EntitySpaces.Core.dll
EntitySpaces.Interfaces.dll

EntitySpaces.SqlClientProvider.dll
EntitySpaces.SqlCeClientProvider.dll
EntitySpaces.MSAccessProvider.dll
EntitySpaces.OracleClientProvider.dll
EntitySpaces.MySqlClientProvider.dll
EntitySpaces.VistaDBProvider.dll
EntitySpaces.NpgsqlProvider.dll

EntitySpaces.Web.dll
EntitySpaces.Web.Design.dll
EntitySpaces.Loader.dll
EntitySpaces.LoaderMT.dll

EntitySpaces.Core.CF.dll
EntitySpaces.Interfaces.CF.dll
EntitySpaces.SqlCeClientProvider.CF.dll
EntitySpaces.VistaDBProvider.CF.dll
EntitySpaces.Loader.CF.dll
EntitySpaces.LoaderMT.CF.dll

Binary Redistributables for EntitySpaces 2007
=============================================
EntitySpace.Core.dll
EntitySpaces.Interfaces.dll

EntitySpaces.SqlClientProvider.dll
EntitySpaces.MSAccessProvider.dll
EntitySpaces.OracleClientProvider.dll
EntitySpaces.MySqlClientProvider.dll
EntitySpaces.VistaDBProvider.dll
EntitySpaces.NpgsqlProvider.dll

EntitySpaces.Web.dll
EntitySpaces.Web.Design.dll
EntitySpaces.Loader.dll
EntitySpaces.LoaderMT.dll

EntitySpaces.Core.Ce.dll
EntitySpaces.Interfaces.Ce.dll
EntitySpaces.SqlClientProvider.Ce.dll
EntitySpaces.VistaDBProvider.Ce.dll
EntitySpaces.Loader.Ce.dll
EntitySpaces.LoaderMT.Ce.dll

EntitySpaces binary redistributables cannot be used by third parties to build
applications or components.

** NOTE: **
==================================
The EntitySpaces.MetadataEngine.dll is a NON-redistributables binary assembly. This 
assembly CANNOT be distributed for any reason or used to build any third party
applications.

Source code generated by the EntitySpaces templates for MyGeneration is a 
derivative work. When used under a valid License, EntitySpaces, LLC grants 
Customer the right to use, modify, and redistribute any source code generated
by the EntitySpaces templates for MyGeneration or CodeSmith.

Customer that has purchased Source Code License may alter the EntitySpaces Core,
Interfaces, or Provider(s) source code and distribute the modified binary 
redistributables with applications. Customer created binary redistributables 
from the EntitySpaces source code cannot be used by anyone, including the 
original license holder, to create a product that competes with the EntitySpaces 
.NET Architecture. Customer created binary redistributables from the 
EntitySpaces source code cannot be used by third parties to build applications 
or components. Neither the original nor altered source code may be distributed.

EXCEPT AS EXPRESSLY AUTHORIZED ABOVE, CUSTOMER SHALL NOT: COPY, IN WHOLE OR IN 
PART, SOFTWARE OR DOCUMENTATION; MODIFY THE SOFTWARE; REVERSE COMPILE OR REVERSE 
ASSEMBLE ALL OR ANY PORTION OF THE SOFTWARE; OR RENT, LEASE, DISTRIBUTE, SELL, 
MAKE AVAILABLE FOR DOWNLOAD, OR CREATE DERIVATIVE WORKS OF THE SOFTWARE OR 
SOURCE CODE. 

Customer agrees that aspects of the licensed materials, including the specific
design and structure of individual programs, constitute trade secrets and/or 
copyrighted material of EntitySpaces, LLC. Customer agrees not to disclose, 
provide, or otherwise make available such trade secrets or copyrighted material 
in any form to any third party without the prior written consent of EntitySpaces, 
LLC. Customer agrees to implement reasonable security measures to protect such 
trade secrets and copyrighted material. Title to Software and documentation 
shall remain solely with EntitySpaces, LLC.

Not for Resale Software
=======================
Software identified as "Not for Resale" or "NFR," may not be sold or otherwise 
transferred for value or given away, or used for any purpose other than 
demonstration, test or evaluation.

No Warranty
=======================
THE SOFTWARE IS BEING DELIVERED TO YOU "AS IS" AND EntitySpaces, LLC MAKES NO
WARRANTY AS TO ITS USE, RELIABILITY OR PERFORMANCE. EntitySpaces, LLC DOES NOT
AND CANNOT WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY USING THE 
SOFTWARE. EntitySpaces, LLC MAKES NO WARRANTIES, EXPRESS OR IMPLIED, AS TO 
NONINFRINGEMENT OF THIRD PARTY RIGHTS, TITLE, MERCHANTABILITY, OR FITNESS FOR
ANY PARTICULAR PURPOSE. YOU ASSUME ALL RISK ASSOCIATED WITH THE QUALITY, 
PERFORMANCE, INSTALLATION AND USE OF THE SOFTWARE INCLUDING, BUT NOT LIMITED TO, 
THE RISKS OF PROGRAM ERRORS, DAMAGE TO EQUIPMENT, LOSS OF DATA OR SOFTWARE 
PROGRAMS, OR UNAVAILABILITY OR INTERRUPTION OF OPERATIONS. YOU ARE SOLELY 
RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USE OF THE SOFTWARE AND 
ASSUME ALL RISKS ASSOCIATED WITH ITS USE.

Indemnification
=======================
You agree to indemnify and hold EntitySpaces, LLC, parents, subsidiaries, 
affiliates, officers and employees, harmless from any claim or demand, 
including reasonable attorneys' fees, made by any third party due to or arising 
out of your use of the Software, or the infringement by you, of any intellectual 
property or other right of any person or entity.

Limitation of Liability
=======================
IN NO EVENT WILL EntitySpaces, LLC BE LIABLE TO YOU FOR ANY INDIRECT, INCIDENTAL, 
SPECIAL, PUNITIVE, CONSEQUENTIAL, OR OTHER DAMAGES WHATSOEVER, OR ANY LOSS OF 
REVENUE, DATA, USE, OR PROFITS, EVEN IF EntitySpaces, LLC HAS BEEN ADVISED OF 
THE POSSIBILITY OF SUCH DAMAGES, AND REGARDLESS OF WHETHER THE CLAIM IS BASED 
UPON ANY CONTRACT, TORT OR OTHER LEGAL OR EQUITABLE THEORY.

This License is effective until terminated. Customer may terminate this License 
at any time by destroying all copies of Software including any documentation. 
This License will terminate immediately without notice from EntitySpaces, LLC 
if Customer fails to comply with any provision of this License. Upon termination, 
Customer must destroy all copies of Software.

Software, including technical data, is subject to U.S. export control laws, 
including the U.S. Export Administration Act and its associated regulations, 
and may be subject to export or import regulations in other countries. Customer 
agrees to comply strictly with all such regulations and acknowledges that it 
has the responsibility to obtain licenses to export, re-export, or import 
Software.

This License shall be governed by and construed in accordance with the laws of 
the State of Indiana, United States of America, as if performed wholly within 
the state and without giving effect to the principles of conflict of law. If 
any portion hereof is found to be void or unenforceable, the remaining 
provisions of this License shall remain in full force and effect. This License 
constitutes the entire License between the parties with respect to the use of 
the Software.
------------------------------------------------------------------------------- 
*/

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Data;

using EntitySpaces.MetadataEngine;

using VistaDB;
using VistaDB.DDA;
using VistaDB.Provider;

namespace EntitySpaces.MetadataEngine.VistaDB
{
    public class VistaDB3xPlugin : IPlugin
	{
        bool useOldForeignKeyWay = false;

		#region IPlugin Interface

		private IContext context;


        bool IPlugin.OnLoad()
        {
            return true;
        }

        void IPlugin.OnUnload()
        {

        }

        void IPlugin.Initialize(IContext context)
        {
            this.context = context;
        }

        string IPlugin.ProviderName
        {
            get { return @"VistaDB 3.x"; }
        }

        string IPlugin.ProviderUniqueKey
        {
            get { return @"VISTADB"; }
        }

        string IPlugin.ProviderAuthorInfo
        {
            get { return @"VistaDB 3.x Plugin Written by EntitySpaces, LLC"; }
        }

        Uri IPlugin.ProviderAuthorUri
        {
            get { return new Uri(@"http://www.entityspaces.net/"); }
        }

        bool IPlugin.StripTrailingNulls
        {
            get { return false; }
        }

        bool IPlugin.RequiredDatabaseName
        {
            get { return false; }
        }

        string IPlugin.SampleConnectionString
        {
            get { return @"Data Source=C:\Program Files\VistaDB 3.3\Data\Northwind.vdb3;OpenMode=NonexclusiveReadOnly"; }
        }

        IDbConnection IPlugin.NewConnection
        {
            get
            {
                if (IsIntialized)
				{
                    VistaDBConnection cn = new VistaDBConnection(this.context.ConnectionString);
                    cn.Open();
					return cn as IDbConnection;
				}
                else
                    return null;
            }
        }

        string IPlugin.DefaultDatabase
        {
            get
            {
				return this.GetDatabaseName();
            }
        }

        DataTable IPlugin.Databases
        {
            get
            {
				DataTable metaData = new DataTable();
				IVistaDBDatabase db = null;

                try
                {
                    metaData = context.CreateDatabasesDataTable();

                    DataRow row = metaData.NewRow();
                    metaData.Rows.Add(row);

                    using (VistaDBConnection cn = new VistaDBConnection(context.ConnectionString))
                    {
                        db = DDA.OpenDatabase(this.GetFullDatabaseName(), VistaDBDatabaseOpenMode.NonexclusiveReadOnly, GetPassword(cn));
                    }

                    row["CATALOG_NAME"] = GetDatabaseName();
                    row["DESCRIPTION"] = db.Description;
                }
                catch (Exception ex)
                {
                    string s = ex.Message;
                }
				finally
				{
					if(db != null) db.Close();
				}

				return metaData;
            }
        }

        DataTable IPlugin.GetTables(string database)
        {
			DataTable metaData = new DataTable();
			IVistaDBDatabase db = null;

            try
            {
                metaData = context.CreateTablesDataTable();

                using (VistaDBConnection cn = new VistaDBConnection(context.ConnectionString))
                {
                    db = DDA.OpenDatabase(this.GetFullDatabaseName(), VistaDBDatabaseOpenMode.NonexclusiveReadOnly, GetPassword(cn));
                }

                ArrayList tables = db.EnumTables();

                foreach (string table in tables)
                {
                    IVistaDBTableSchema tblStructure = db.TableSchema(table);

                    DataRow row = metaData.NewRow();
                    metaData.Rows.Add(row);

                    row["TABLE_NAME"] = tblStructure.Name;
                    row["DESCRIPTION"] = tblStructure.Description;
                }
            }
            finally
            {
                if (db != null) db.Close();
            }

			return metaData;
        }

		DataTable IPlugin.GetViews(string database)
		{
			DataTable metaData = new DataTable();

			try
			{
				metaData = context.CreateViewsDataTable();

                using (VistaDBConnection conn = new VistaDBConnection(context.ConnectionString))
				{
					using (VistaDBCommand cmd = new VistaDBCommand("SELECT * FROM GetViews()", conn))
					{
						using (VistaDBDataAdapter da = new VistaDBDataAdapter(cmd))
						{
							DataTable views = new DataTable();
							da.Fill(views);

							foreach(DataRow vistaRow in views.Rows)
							{
								DataRow row = metaData.NewRow();
								metaData.Rows.Add(row);

								row["TABLE_NAME"]   = vistaRow["VIEW_NAME"];
								row["DESCRIPTION"]  = vistaRow["DESCRIPTION"];
								row["VIEW_TEXT"]    = vistaRow["VIEW_DEFINITION"];
								row["IS_UPDATABLE"] = vistaRow["IS_UPDATABLE"];
							}
						}						 
					}
				}
			}
			catch{}

			return metaData;
		}

        DataTable IPlugin.GetProcedures(string database)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetDomains(string database)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetProcedureParameters(string database, string procedure)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetProcedureResultColumns(string database, string procedure)
        {
            return new DataTable();
        }

        DataTable IPlugin.GetViewColumns(string database, string view)
        {
			DataTable metaData = new DataTable();

			try
			{
				metaData = context.CreateColumnsDataTable();

                using (VistaDBConnection conn = new VistaDBConnection(context.ConnectionString))
				{
					string sql = "SELECT * FROM GetViewColumns('" + view + "')";

					using (VistaDBCommand cmd = new VistaDBCommand(sql, conn))
					{
						using (VistaDBDataAdapter da = new VistaDBDataAdapter(cmd))
						{
							DataTable views = new DataTable();
							da.Fill(views);

							foreach(DataRow vistaRow in views.Rows)
							{
								DataRow row = metaData.NewRow();
								metaData.Rows.Add(row);

								int width		= Convert.ToInt32(vistaRow["COLUMN_SIZE"]);
								int dec			= 0; 
								int length      = 0;
								int octLength   = width;
								bool timestamp  = false;

								string type = vistaRow["DATA_TYPE_NAME"] as string;

								switch(type)
								{
									case "Char":
									case "NChar":
									case "NText":
									case "NVarchar":
									case "Text":
									case "Varchar":
										length = width;
										width  = 0;
										dec    = 0;
										break;

									case "Currency":
									case "Double":
									case "Decimal":
									case "Single":
										break;

									case "Timestamp":
										timestamp = true;
										break;

									default:
										width = 0;
										dec   = 0;
										break;
								}

								string def = Convert.ToString(vistaRow["DEFAULT_VALUE"]);

								row["TABLE_NAME"] = view;
								row["COLUMN_NAME"] = vistaRow["COLUMN_NAME"];
								row["ORDINAL_POSITION"] = vistaRow["COLUMN_ORDINAL"];
								row["IS_NULLABLE"] = vistaRow["ALLOW_NULL"];
								row["COLUMN_HASDEFAULT"] = def == string.Empty ? false : true;
								row["COLUMN_DEFAULT"] = def;
								row["IS_AUTO_KEY"] = vistaRow["IDENTITY_VALUE"];
								row["AUTO_KEY_SEED"] = vistaRow["IDENTITY_SEED"];
								row["AUTO_KEY_INCREMENT"] = vistaRow["IDENTITY_STEP"];
								row["TYPE_NAME"] = type;
								row["NUMERIC_PRECISION"] = width;
								row["NUMERIC_SCALE"] = dec;
								row["CHARACTER_MAXIMUM_LENGTH"] = length;
								row["CHARACTER_OCTET_LENGTH"] = octLength;
								row["DESCRIPTION"] = vistaRow["COLUMN_DESCRIPTION"];
                                row["TYPE_NAME_COMPLETE"] = this.GetDataTypeNameComplete(type, length, (short)width, (short)dec);

								if (timestamp)
								{
									row["IS_COMPUTED"] = true;
								}
							}
						}						 
					}
				}
			}
			catch{}

			return metaData;
        }

        DataTable IPlugin.GetTableColumns(string database, string table)
        {
			DataTable metaData = new DataTable();
			IVistaDBDatabase db = null;

			try
			{
				metaData = context.CreateColumnsDataTable();

                using (VistaDBConnection cn = new VistaDBConnection(context.ConnectionString))
                {
                    db = DDA.OpenDatabase(this.GetFullDatabaseName(), VistaDBDatabaseOpenMode.NonexclusiveReadOnly, GetPassword(cn));
                }

				ArrayList tables = db.EnumTables();

				IVistaDBTableSchema tblStructure = db.TableSchema(table);

				foreach (IVistaDBColumnAttributes c in tblStructure) 
				{ 
					string colName = c.Name;

					string def = "";
					if(tblStructure.Defaults.Contains(colName))
					{
						def = tblStructure.Defaults[colName].Expression;
					}
					int width		= c.MaxLength; //c.ColumnWidth;
					int dec			= 0; //c.ColumnDecimals;
					int length      = 0;
					int octLength   = width;

					IVistaDBIdentityInformation identity = null;
					if(tblStructure.Identities.Contains(colName))
					{
						identity = tblStructure.Identities[colName];
					}

					string[] pks = null;
					if(tblStructure.Indexes.Contains("PrimaryKey"))
					{
						pks = tblStructure.Indexes["PrimaryKey"].KeyExpression.Split(';');
					}
					else
					{
						foreach(IVistaDBIndexInformation pk in tblStructure.Indexes)
						{
							if(pk.Primary)
							{
								pks = pk.KeyExpression.Split(';');
								break;
							}
						}
					}

					System.Collections.Hashtable pkCols = null;
					if(pks != null)
					{
						pkCols = new Hashtable();
						foreach(string pkColName in pks)
						{
							pkCols[pkColName] = true;
						}
					}

					switch(c.Type)
					{
						case VistaDBType.Char:
						case VistaDBType.NChar:
						case VistaDBType.NText:
						case VistaDBType.NVarChar:
						case VistaDBType.Text:
						case VistaDBType.VarChar:
							length    = width;
							width     = 0;
							dec       = 0;
							break;

						case VistaDBType.Money:
						case VistaDBType.Float:
						case VistaDBType.Decimal:
						case VistaDBType.Real:
							break;

						default:
							width = 0;
							dec   = 0;
							break;
					}

					DataRow row = metaData.NewRow();
					metaData.Rows.Add(row);

					row["TABLE_NAME"] = tblStructure.Name;
					row["COLUMN_NAME"] = c.Name;
					row["ORDINAL_POSITION"] = c.RowIndex;
					row["IS_NULLABLE"] = c.AllowNull;
					row["COLUMN_HASDEFAULT"] = def == string.Empty ? false : true;
					row["COLUMN_DEFAULT"] = def;
					row["IS_AUTO_KEY"] = identity == null ? false : true;
					row["AUTO_KEY_SEED"] = 1;
					row["AUTO_KEY_INCREMENT"] = identity == null ? 0 : Convert.ToInt32(identity.StepExpression);
					row["TYPE_NAME"] = c.Type.ToString();
					row["NUMERIC_PRECISION"] = width;
					row["NUMERIC_SCALE"] = dec;
					row["CHARACTER_MAXIMUM_LENGTH"] = length;
					row["CHARACTER_OCTET_LENGTH"] = octLength;
					row["DESCRIPTION"] = c.Description;

                    string type = (string)row["TYPE_NAME"];
                    row["TYPE_NAME_COMPLETE"] = this.GetDataTypeNameComplete(type, length, (short)width, (short)dec);

					if (c.Type == VistaDBType.Timestamp)
					{
						row["IS_COMPUTED"] = true;
					}

                    row["IS_CONCURRENCY"] = type == "Timestamp" ? true : false; 
				} 

			}
			finally
			{
				if(db != null) db.Close();
			}

			return metaData;
        }

        List<string> IPlugin.GetPrimaryKeyColumns(string database, string table)
        {
			List<string> primaryKeys = new List<string>();
			IVistaDBDatabase db = null;

			try
			{
                using (VistaDBConnection cn = new VistaDBConnection(context.ConnectionString))
                {
                    db = DDA.OpenDatabase(this.GetFullDatabaseName(), VistaDBDatabaseOpenMode.NonexclusiveReadOnly, GetPassword(cn));
                }

				IVistaDBTableSchema tblStructure = db.TableSchema(table);

				string[] pks = null;
				if(tblStructure.Indexes.Contains("PrimaryKey"))
				{
					pks = tblStructure.Indexes["PrimaryKey"].KeyExpression.Split(';');
				}
				else
				{
					foreach(IVistaDBIndexInformation pk in tblStructure.Indexes)
					{
						if(pk.Primary)
						{
							pks = pk.KeyExpression.Split(';');
							break;
						}
					}
				}

				if(pks != null)
				{
					foreach(string pkColName in pks)
					{
						primaryKeys.Add(pkColName);
					}
				}
			}
			finally
			{
				if(db != null) db.Close();
			}

			return primaryKeys;
        }

        List<string> IPlugin.GetViewSubViews(string database, string view)
        {
            return new List<string>();
        }

        List<string> IPlugin.GetViewSubTables(string database, string view)
        {
            return new List<string>();
        }

        DataTable IPlugin.GetTableIndexes(string database, string table)
        {
			DataTable metaData = new DataTable();
			IVistaDBDatabase db = null;

			try
			{
				metaData = context.CreateIndexesDataTable();

                using (VistaDBConnection cn = new VistaDBConnection(context.ConnectionString))
                {
                    db = DDA.OpenDatabase(this.GetFullDatabaseName(), VistaDBDatabaseOpenMode.NonexclusiveReadOnly, GetPassword(cn));
                }

				ArrayList tables = db.EnumTables();

				IVistaDBTableSchema tblStructure = db.TableSchema(table);

				foreach (IVistaDBIndexInformation indexInfo in tblStructure.Indexes) 
				{ 
					string[] pks = indexInfo.KeyExpression.Split(';');

					int index = 0;
					foreach(string colName in pks)
					{
						DataRow row = metaData.NewRow();
						metaData.Rows.Add(row);

						row["TABLE_CATALOG"] = GetDatabaseName();
						row["TABLE_NAME"] = tblStructure.Name;
						row["INDEX_CATALOG"] = GetDatabaseName();
						row["INDEX_NAME"] = indexInfo.Name;
						row["UNIQUE"] = indexInfo.Unique;
						row["COLLATION"] = indexInfo.KeyStructure[index++].Descending ? 2 : 1;
						row["COLUMN_NAME"] = colName;
					}
				} 
			}
			finally
			{
				if(db != null) db.Close();
			}

			return metaData;
        }

        DataTable IPlugin.GetForeignKeys(string database, string tableName)
        {
			DataTable metaData = new DataTable();
			IVistaDBDatabase db = null;

			try
			{
				metaData = context.CreateForeignKeysDataTable();

                using (VistaDBConnection cn = new VistaDBConnection(context.ConnectionString))
                {
                    db = DDA.OpenDatabase(this.GetFullDatabaseName(), VistaDBDatabaseOpenMode.NonexclusiveReadOnly, GetPassword(cn));
                }

				ArrayList tables = db.EnumTables(); 

				foreach (string table in tables) 
				{
					IVistaDBTableSchema tblStructure = db.TableSchema(table);

                    //==================================================================
                    // This works around a change that was made to the VistaDB provider
                    // It's ugly, we know
                    //==================================================================
                    IEnumerator enumerator = null;

                    if (useOldForeignKeyWay)
                    {
                        enumerator = tblStructure.ForeignKeys.GetEnumerator();
                    }
                    else
                    {
                        try
                        {
                            enumerator = tblStructure.ForeignKeys.Values.GetEnumerator();
                        }
                        catch
                        {
                            enumerator = tblStructure.ForeignKeys.GetEnumerator();
                            useOldForeignKeyWay = true;
                        }
                    }

                    // Okay, now that the version issues are over we just use the 'enumerator'
                    while(enumerator.MoveNext())
                    {
                        IVistaDBRelationshipInformation relInfo = enumerator.Current as IVistaDBRelationshipInformation;

						if(relInfo.ForeignTable != tableName && relInfo.PrimaryTable != tableName)
							continue;

						string fCols = relInfo.ForeignKey; 
						string pCols = String.Empty; 

						string primaryTbl  = relInfo.PrimaryTable; 
						string pkName = "";

						using (IVistaDBTableSchema pkTableStruct = db.TableSchema(primaryTbl)) 
						{ 
							foreach (IVistaDBIndexInformation idxInfo in pkTableStruct.Indexes) 
							{ 
								if (!idxInfo.Primary) 
								continue; 
								        
								pkName = idxInfo.Name;
								pCols = idxInfo.KeyExpression; 
								break; 
							} 
						} 

						string [] fColumns = fCols.Split(';'); 
						string [] pColumns = pCols.Split(';'); 

						for(int i = 0; i < fColumns.GetLength(0); i++)
						{
							DataRow row = metaData.NewRow();
							metaData.Rows.Add(row);

							row["PK_TABLE_CATALOG"] = GetDatabaseName();
							row["PK_TABLE_SCHEMA"]  = DBNull.Value;
							row["FK_TABLE_CATALOG"] = DBNull.Value;
							row["FK_TABLE_SCHEMA"]  = DBNull.Value;
							row["FK_TABLE_NAME"]    = tblStructure.Name;
							row["PK_TABLE_NAME"]    = relInfo.PrimaryTable;
							row["ORDINAL"]          = 0;
							row["FK_NAME"]          = relInfo.Name;
							row["PK_NAME"]          = pkName;
							row["PK_COLUMN_NAME"]   = pColumns[i]; 
							row["FK_COLUMN_NAME"]   = fColumns[i];

							row["UPDATE_RULE"]		= relInfo.UpdateIntegrity;
							row["DELETE_RULE"]		= relInfo.DeleteIntegrity;
						}
					} 
				}
			}
			finally
			{
				if(db != null) db.Close();
			}

			return metaData;
        }

        public object GetDatabaseSpecificMetaData(object myMetaObject, string key)
        {
            return null;
        }

		#endregion

		#region Internal Methods
		private IVistaDBDDA DDA = VistaDBEngine.Connections.OpenDDA();

        private bool IsIntialized 
		{ 
			get 
			{ 
				return (context != null); 
			} 
		}

		public string GetDatabaseName()
		{
			VistaDBConnection cn = new VistaDBConnection(this.context.ConnectionString);

			string dbName = cn.DataSource;
			int index = dbName.LastIndexOfAny(new char[]{'\\'});
			if (index >= 0)
			{
				dbName = dbName.Substring(index + 1);
			}
			return dbName;
		}

		public string GetFullDatabaseName()
		{
			VistaDBConnection cn = new VistaDBConnection(this.context.ConnectionString);
			return cn.DataSource;
		}

        private string GetDataTypeNameComplete(string dataType, int charMax, short precision, short scale)
        {
            switch (dataType)
            {
                case "Char":
                case "NChar":
                case "Text":
                case "NText":
                case "VarChar":
                case "NVarChar":
                case "varbinary":
                    return dataType + "(" + charMax + ")";

                case "Decimal":
                case "Money":
                case "SmallMoney":
                    return dataType + "(" + precision + "," + scale + ")";

                default:
                    return dataType;
            }
        }

        private string GetPassword(VistaDBConnection conn)
        {
            string password = null;

            if (conn.Password != null && conn.Password.Length > 0)
            {
                password = conn.Password;
            }

            return password;
        }

		#endregion
	}
}